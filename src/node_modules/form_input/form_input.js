const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = form_input
async function form_input (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject,
    data: ondata
  }

  let current_step = null
  let input_accessible = true
  let mid = 0

  let _ = { up: null }
  if (protocol) {
    const send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="input-display">
    <div class='test'>
      <input class="input-field" type="text" placeholder="Type to submit">
    </div>
    <div class="overlay-lock" hidden></div>
  </div>
  <style>
  </style>`
  const style = shadow.querySelector('style')

  const input_field_el = shadow.querySelector('.input-field')
  const overlay_el = shadow.querySelector('.overlay-lock')

  input_field_el.oninput = async function () {
    if (!input_accessible) return
    await drive.put('data/form_input.json', {
      input_field: this.value
    })
    if (this.value.length >= 10) {
      const head = [by, to, mid++]
      const refs = {}
      _.up({
        head,
        refs,
        type: 'action_submitted',
        data: {
          value: this.value,
          index: current_step?.index || 0
        }
      })
      console.log('mark_as_complete')
    } else {
      const head = [by, to, mid++]
      const refs = {}
      _.up({
        head,
        refs,
        type: 'action_incomplete',
        data: {
          value: this.value,
          index: current_step?.index || 0
        }
      })
    }
  }

  await sdb.watch(onbatch)
  const parent_handler = {
    step_data,
    reset_data
  }

  return el

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }

  function inject (data) {
    style.replaceChildren((() => {
      const style_el = document.createElement('style')
      style_el.textContent = data[0]
      return style_el
    })())
  }

  function ondata (data) {
    if (data && data.length > 0) {
      const input_data = data[0]
      if (input_data && input_data.input_field) {
        input_field_el.value = input_data.input_field
      }
    } else {
      input_field_el.value = ''
    }
  }

  function onmessage ({ type, data }) {
    console.log('message from form_input', type, data)
    parent_handler[type]?.(data, type)
  }

  function step_data (data, type) {
    current_step = data

    input_accessible = data?.is_accessible !== false

    overlay_el.hidden = input_accessible

    input_field_el.placeholder = input_accessible
      ? 'Type to submit'
      : 'Input disabled for this step'
  }

  function reset_data (data, type) {
    input_field_el.value = ''
    drive.put('data/form_input.json', {
      input_field: ''
    })
  }
}
function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: {
        $: ''
      }
    }
  }
  function fallback_instance () {
    return {
      _: {
        DOCS: {
          0: ''
        }
      },
      drive: {
        'style/': {
          'theme.css': {
            raw: `
            .input-display {
              background: #131315;
              border-radius: 16px;
              border: 1px solid #3c3c3c;
              display: flex;
              flex: 1;
              align-items: center;
              padding: 0 12px;
              min-height: 32px;
              position: absolute;
              bottom: 90px;
              right: 20px;
              z-index: 4;
            }
            .input-display:focus-within {
              border-color: #4285f4;
              background: #1a1a1c;
            }
            .input-field {
              flex: 1;
              min-height: 32px;
              background: transparent;
              border: none;
              color: #e8eaed;
              padding: 0 12px;
              font-size: 14px;
              outline: none;
            }
            .input-field::placeholder {
              color: #a6a6a6;
            }
            .overlay-lock {
              position: absolute;
              inset: 0;
              background: transparent;
              z-index: 10;
              cursor: not-allowed;
            }`
          }
        },
        'data/': {
          'form_input.json': {
            raw: {
              input_field: ''
            }
          }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        }
      }
    }
  }
}
