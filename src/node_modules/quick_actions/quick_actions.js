const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = quick_actions

async function quick_actions (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject,
    icons: iconject,
    hardcons: onhardcons,
    actions: onactions,
    prefs: onprefs
  }

  const el = document.createElement('div')
  el.style.display = 'flex'
  el.style.flex = 'auto'

  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
  <div class="quick-actions-container main">
    <div class="default-actions"></div>
    <div class="text-bar" role="button"></div>
    <div class="input-wrapper" style="display: none;">
      <div class="input-display">
        <span class="slash-prefix">/</span>
        <span class="command-text"></span>
        <span class="step-display" style="display: none;">
          <span>steps:</span>
          <span class="current-step">1</span>
          <span class="step-separator">-</span>
          <span class="total-step">1</span>
        </span>
        <input class="input-field" type="text" placeholder="Type to search actions...">
        <div class="input-tooltip" style="display: none;"></div>
      </div>
      <button class="confirm-btn" style="display: none;"></button>
      <button class="submit-btn" style="display: none;"></button>
      <button class="close-btn"></button>
    </div>
    <div class="tooltip hide"></div>
  </div>
  <style>
  </style>`
  const container = shadow.querySelector('.quick-actions-container')
  const default_actions = shadow.querySelector('.default-actions')
  const text_bar = shadow.querySelector('.text-bar')
  const input_wrapper = shadow.querySelector('.input-wrapper')
  const slash_prefix = shadow.querySelector('.slash-prefix')
  const command_text = shadow.querySelector('.command-text')
  const input_field = shadow.querySelector('.input-field')
  const confirm_btn = shadow.querySelector('.confirm-btn')
  const submit_btn = shadow.querySelector('.submit-btn')
  const close_btn = shadow.querySelector('.close-btn')
  const step_display = shadow.querySelector('.step-display')
  const current_step = shadow.querySelector('.current-step')
  const total_steps = shadow.querySelector('.total-step')
  const tooltip = shadow.querySelector('.tooltip')
  const input_tooltip = shadow.querySelector('.input-tooltip')
  const style = shadow.querySelector('style')

  let init = false
  let mid = 0
  let enable_quick_action_tooltips = false
  let enable_input_field_tooltips = false
  let icons = {}
  let hardcons = {}
  let defaults = []
  let stored_selected_action = ''
  let action_selected = false
  const docs = DOCS(__filename)(opts.sid)

  let send = null
  const _ = {
    up: null
  }
  if (protocol) {
    send = protocol(onmessage)
    _.up = send
  }
  text_bar.onclick = docs.wrap(activate_input_field, get_doc_content)
  close_btn.onclick = docs.wrap(deactivate_input_field, get_doc_content)
  confirm_btn.onclick = docs.wrap(onconfirm, get_doc_content)
  submit_btn.onclick = docs.wrap(onsubmit, get_doc_content)
  input_field.oninput = oninput

  await sdb.watch(onbatch)

  return el

  async function get_doc_content () {
    const doc_file = await drive.get('docs/README.md')
    return doc_file && doc_file.raw ? doc_file.raw : 'No documentation available'
  }

  function onsubmit () {
    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'action_submitted' })
  }

  function onconfirm () {
    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'activate_steps_wizard', data: stored_selected_action })
  }
  function oninput (e) {
    const value = e.target.value
    if (enable_input_field_tooltips) update_input_tooltip(value)
    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'filter_actions', data: value })
  }

  function update_input_display (selected_action = null) {
    if (selected_action) {
      action_selected = true
      slash_prefix.style.display = 'inline'
      command_text.style.display = 'inline'
      command_text.textContent = `#${selected_action.action}`
      current_step.textContent = selected_action && selected_action.current_step ? selected_action.current_step : 1
      total_steps.textContent = selected_action && selected_action.total_steps ? selected_action.total_steps : 1
      step_display.style.display = 'inline-flex'

      input_field.style.display = 'none'
      confirm_btn.style.display = 'flex'
      hide_input_tooltip()
    } else {
      slash_prefix.style.display = 'none'
      command_text.style.display = 'none'
      input_field.style.display = 'block'
      confirm_btn.style.display = 'none'
      submit_btn.style.display = 'none'
      step_display.style.display = 'none'
      input_field.placeholder = 'Type to search actions...'
      hide_input_tooltip()
      action_selected = false
    }
  }

  function activate_input_field () {
    if (action_selected) return
    default_actions.style.display = 'none'
    text_bar.style.display = 'none'

    input_wrapper.style.display = 'flex'
    input_field.focus()

    if (enable_input_field_tooltips) update_input_tooltip('')

    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'display_actions', data: { display: 'block', reason: 'browse' } })
  }

  function onmessage (msg) {
    const { type, data } = msg
    // No need to handle docs_toggle - DOCS module handles it globally
    const message_map = {
      deactivate_input_field,
      show_submit_btn,
      update_current_step,
      hide_submit_btn,
      update_quick_actions_for_app,
      update_input_command
    }
    const handler = message_map[type] || fail
    handler(data)
  }

  function deactivate_input_field (data) {
    const reason = data && data.reason ? data.reason : 'cancel'

    default_actions.style.display = 'flex'
    text_bar.style.display = 'flex'

    input_wrapper.style.display = 'none'

    input_field.value = ''
    update_input_display()
    hide_input_tooltip()

    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'display_actions', data: { display: 'none', reason } })
  }

  function show_submit_btn () { submit_btn.style.display = 'flex' }
  function hide_submit_btn () { submit_btn.style.display = 'none' }

  function update_current_step (data) {
    const current_step_value = data && data.index !== undefined ? data.index + 1 : 1
    current_step.textContent = current_step_value
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init) {
      create_default_actions(defaults)
      init = true
    } else {
      // TODO: update actions
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }
  function fail (data, type) { console.warn(`Invalid message type: ${type}`, { cause: { data, type } }) }

  function inject (data) { style.innerHTML = data.join('\n') }
  function onhardcons (data) {
    hardcons = {
      submit: data[0],
      cross: data[1],
      confirm: data[2]
    }
    submit_btn.innerHTML = hardcons.submit
    close_btn.innerHTML = hardcons.cross
    confirm_btn.innerHTML = hardcons.confirm
  }
  function iconject (data) { icons = data }

  function onactions (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    defaults = vars
    create_default_actions(defaults)
  }

  function onprefs (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    enable_input_field_tooltips = vars.input_field
    enable_quick_action_tooltips = vars.quick_actions
  }

  function create_default_actions (actions) {
    default_actions.replaceChildren()
    actions.forEach(create_action_button)
  }

  function create_action_button (action) {
    const btn = document.createElement('div')
    btn.classList.add('action-btn')
    if (icons[action.icon] === undefined) {
      const texon = action.name.substring(0, 2)
      btn.innerHTML = texon
    } else {
      btn.innerHTML = icons[action.icon]
    }
    btn.dataset.name = action.name
    if (enable_quick_action_tooltips) {
      btn.onmouseenter = on_action_btn_mouseenter
      btn.onmouseleave = hide_tooltip
    }
    btn.onclick = docs.wrap(onclick, get_doc_content)
    default_actions.appendChild(btn)

    function on_action_btn_mouseenter () { show_tooltip(btn, action.name) }

    function onclick () {
      const head = [by, to, mid++]
      const refs = {}
      _.up({ head, refs, type: 'update_quick_actions_input', data: action.name })
    }
  }

  function update_input_tooltip (value) {
    if (!value || value.trim() === '') {
      hide_input_tooltip()
      return
    }
    const tooltip_text = get_tooltip_text(value)
    if (tooltip_text) {
      show_input_tooltip(tooltip_text)
    } else {
      hide_input_tooltip()
    }
  }

  function get_tooltip_text (value) {
    const lower_value = value.toLowerCase().trim()
    if (lower_value.length === 0) return null
    if (defaults.length > 0) {
      const matching = defaults.filter(matches_action_for_tooltip)
      if (matching.length > 0) {
        const names = matching.map(get_action_name)
        return `Found ${matching.length} action${matching.length > 1 ? 's' : ''}: ${names.join(', ')}`
      }
    }
    return 'No actions found. Try a different search term.'

    function matches_action_for_tooltip (action) { return matches_action(action, lower_value) }
    function get_action_name (action) { return action.name }
  }

  function matches_action (action, search_term) { return action.name.toLowerCase().includes(search_term) }

  function show_input_tooltip (text) {
    input_tooltip.textContent = text
    input_tooltip.style.display = 'block'
    position_input_tooltip()
  }

  function hide_input_tooltip () { input_tooltip.style.display = 'none' }

  function position_input_tooltip () {
    const input_rect = input_field.getBoundingClientRect()
    const wrapper_rect = input_wrapper.getBoundingClientRect()
    const tooltip_rect = input_tooltip.getBoundingClientRect()
    const left = input_rect.left - wrapper_rect.left + (input_rect.width / 2) - (tooltip_rect.width / 2)
    const top = input_rect.top - wrapper_rect.top - tooltip_rect.height - 8
    input_tooltip.style.left = `${left}px`
    input_tooltip.style.top = `${top}px`
  }

  function update_quick_actions_for_app (data) {
    if (data) {
      drive.put('actions/default.json', data)
    }
  }

  function update_input_command (command) {
    if (action_selected) return
    stored_selected_action = command
    if (input_wrapper.style.display === 'none') {
      default_actions.style.display = 'none'
      text_bar.style.display = 'none'
      input_wrapper.style.display = 'flex'
      input_field.focus()
      if (enable_input_field_tooltips) update_input_tooltip('')
    }

    // Find the action that matches the command
    const matching_action = defaults.find(matches_selected_command)

    if (matching_action) {
      const pass_data = {
        action: matching_action.name,
        current_step: 1,
        total_steps: 3
      }
      update_input_display(pass_data)
    } else {
      // TODO: Strictly handle this case
      const pass_data = {
        action: command.action,
        current_step: 1,
        total_steps: 3
      }
      update_input_display(pass_data)
    }

    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'display_actions', data: { display: 'none', reason: 'selected' } })

    function matches_selected_command (action) { return action.name === command || action.action === command }
  }

  function show_tooltip (btn, name) {
    tooltip.textContent = name
    tooltip.style.display = 'block'
    const btn_rect = btn.getBoundingClientRect()
    const container_rect = container.getBoundingClientRect()
    const tooltip_rect = tooltip.getBoundingClientRect()
    const left = btn_rect.left - container_rect.left + (btn_rect.width / 2) - (tooltip_rect.width / 2)
    const top = btn_rect.top - container_rect.top - tooltip_rect.height - 8
    tooltip.style.left = `${left}px`
    tooltip.style.top = `${top}px`
  }

  function hide_tooltip () { tooltip.style.display = 'none' }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: {
        $: ''
      }
    }
  }

  function fallback_instance () {
    return {
      _: {
        DOCS: {
          0: ''
        }
      },
      drive: {
        'icons/': {
          '0.svg': {
            $ref: 'action1.svg'
          },
          '1.svg': {
            $ref: 'action2.svg'
          },
          '2.svg': {
            $ref: 'action1.svg'
          },
          '3.svg': {
            $ref: 'action2.svg'
          },
          '4.svg': {
            $ref: 'action1.svg'
          }
        },
        'hardcons/': {
          'submit.svg': {
            $ref: 'submit.svg'
          },
          'close.svg': {
            $ref: 'cross.svg'
          },
          'confirm.svg': {
            $ref: 'check.svg'
          }
        },
        'actions/': {
          'default.json': {
            raw: JSON.stringify([])
          }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        },
        'style/': {
          'theme.css': {
            raw: `
              .quick-actions-container {
                display: flex;
                flex: auto;
                flex-direction: row;
                align-items: center;
                background: #191919;
                border-radius: 20px;
                gap: 8px;
                min-width: 200px;
                position: relative;
              }
              .default-actions {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 4px;
                padding: 0 4px;
              }
              .action-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                padding: 6px;
                border-radius: 50%;
                cursor: pointer;
                color: #a6a6a6;
              }
              .action-btn:hover {
                background: rgba(255, 255, 255, 0.1);
              }
              .text-bar {
                flex: 1;
                height: 24px;
                margin: 4px;
                border-radius: 16px;
                background: #131315;
                cursor: pointer;
                user-select: none;
              }
              .text-bar:hover {
                background: #1a1a1c;
              }
              .input-wrapper {
                display: flex;
                flex: 1;
                align-items: center;
                background: #131315;
                border-radius: 16px;
                width: auto;
                height: 30px;
                border: 1px solid #3c3c3c;
              }
              .input-wrapper:focus-within {
                border-color: #4285f4;
                background: #1a1a1c;
              }
              .input-display {
                display: flex;
                flex: 1;
                align-items: center;
                padding: 0 12px;
                min-height: 32px;
                position: relative;
              }
              .slash-prefix {
                color: #a6a6a6;
                font-size: 14px;
                margin-right: 4px;
                display: none;
              }
              .command-text {
                color: #e8eaed;
                font-size: 14px;
                background: #2d2d2d;
                border: 1px solid #4285f4;
                border-radius: 4px;
                padding: 2px 6px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                display: none;
              }
              .input-field {
                flex: 1;
                min-height: 32px;
                background: transparent;
                border: none;
                color: #e8eaed;
                padding: 0 12px;
                font-size: 14px;
                outline: none;
              }
              .input-field::placeholder {
                color: #a6a6a6;
              }
              .submit-btn {
                display: none;
                align-items: center;
                justify-content: center;
                background: #ffffff00;
                border: none;
                padding: 6px;
                border-radius: 50%;
                cursor: pointer;
                color: white;
                min-width: 32px;
                height: 32px;
                margin-right: 4px;
                font-size: 12px;
              }
              .submit-btn:hover {
                background: #ffffff00;
              }
              .confirm-btn {
                display: none;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                padding: 6px;
                border-radius: 50%;
                cursor: pointer;
                color: #a6a6a6;
                min-width: 32px;
                height: 32px;
                margin-right: 4px;
                font-size: 12px;
              }
              .confirm-btn:hover {
                background: rgba(255, 255, 255, 0.1);
              }
              .close-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                padding: 6px;
                border-radius: 50%;
                cursor: pointer;
                color: #a6a6a6;
                min-width: 32px;
                height: 32px;
              }
              .close-btn:hover {
                background: rgba(255, 255, 255, 0.1);
              }
              svg {
                width: 16px;
                height: 16px;
              }
              .step-display {
                display: inline-flex;
                align-items: center;
                gap: 2px;
                margin-left: 8px;
                background: #2d2d2d;
                border: 1px solid #666;
                border-radius: 4px;
                padding: 1px 6px;
                font-size: 12px;
                color: #fff;
                font-family: monospace;
              }
              .current-step {
                color:#f0f0f0;
              }
              .step-separator {
                color: #888;
              }
              .total-step {
                color: #f0f0f0;
              }
              .hide {
                display: none;
              }
              .tooltip {
                position: absolute;
                background: #2d2d2d;
                color: #e8eaed;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
                white-space: nowrap;
                pointer-events: none;
                z-index: 1000;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                border: 1px solid #3c3c3c;
              }
              .tooltip::after {
                content: '';
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                border: 4px solid transparent;
                border-top-color: #2d2d2d;
              }
              .input-tooltip {
                position: absolute;
                background: #2d2d2d;
                color: #e8eaed;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
                white-space: normal;
                pointer-events: none;
                z-index: 1001;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                border: 1px solid #4285f4;
                max-width: 300px;
                word-wrap: break-word;
              }
              .input-tooltip::after {
                content: '';
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                border: 4px solid transparent;
                border-top-color: #4285f4;
              }
            `
          }
        },
        'prefs/': {
          'tooltips.json': {
            raw: JSON.stringify({
              quick_actions: true,
              input_field: false
            })
          }
        }
      }
    }
  }
}
