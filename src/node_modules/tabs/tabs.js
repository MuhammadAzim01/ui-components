const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = component

async function component (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    variables: onvariables,
    style: inject,
    icons: iconject,
    scroll: onscroll
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="tab-entries main"></div>
  <style>
  </style>`
  const entries = shadow.querySelector('.tab-entries')
  const style = shadow.querySelector('style')

  let init = false
  let mid = 0
  let variables = []
  let dricons = []
  const docs = DOCS(__filename)(opts.sid)
  
  // Register actions with DOCS system
  const actions_file = await drive.get('actions/commands.json')
  if (actions_file && actions_file.raw) {
    const actions_data = typeof actions_file.raw === 'string' ? JSON.parse(actions_file.raw) : actions_file.raw
    docs.register_actions(actions_data)
  }
  
  await sdb.watch(onbatch)
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(onmessage)
    _ = { up: send }
  }
  if (entries) {
    let is_down = false
    let start_x
    let scroll_start

    function stop_drag_scroll () {
      is_down = false
      entries.classList.remove('grabbing')
      update_scroll_position()
    }

    function move_drag_scroll (pointer_x) {
      if (!is_down) return
      if (entries.scrollWidth <= entries.clientWidth) return stop_drag_scroll()
      entries.scrollLeft = scroll_start - (pointer_x - start_x) * 1.5
    }

    entries.onmousedown = on_entries_mousedown

    function on_entries_mousedown (e) {
      if (entries.scrollWidth <= entries.clientWidth) return
      is_down = true
      entries.classList.add('grabbing')
      start_x = e.pageX - entries.offsetLeft
      scroll_start = entries.scrollLeft
      window.onmousemove = on_window_mousemove
      window.onmouseup = on_window_mouseup
    }

    function on_window_mousemove (e) {
      move_drag_scroll(e.pageX - entries.offsetLeft)
      e.preventDefault()
    }

    function on_window_mouseup () {
      stop_drag_scroll()
      window.onmousemove = null
      window.onmouseup = null
    }

    entries.onmouseleave = stop_drag_scroll
    entries.ontouchstart = on_entries_touchstart

    function on_entries_touchstart (e) {
      if (entries.scrollWidth <= entries.clientWidth) return
      is_down = true
      start_x = e.touches[0].pageX - entries.offsetLeft
      scroll_start = entries.scrollLeft
    }

    ;['ontouchend', 'ontouchcancel'].forEach(bind_touch_end_handler)
    entries.ontouchmove = on_entries_touchmove

    function bind_touch_end_handler (event_name) { entries[event_name] = stop_drag_scroll }
    function on_entries_touchmove (e) {
      move_drag_scroll(e.touches[0].pageX - entries.offsetLeft)
      e.preventDefault()
    }
  }
  return div

  function onmessage (msg) {
    // const { type } = msg
  }

  async function create_btn ({ name, id }, index) {
    const el = document.createElement('div')
    el.innerHTML = `
    <span class="icon">${dricons[index + 1]}</span>
    <span class='name'>${id}</span>
    <span class="name">${name}</span>
    <button class="btn">${dricons[0]}</button>`

    el.className = 'tabsbtn'
    const name_el = el.querySelector('.name')
    const close_btn = el.querySelector('.btn')

    name_el.draggable = false

    // Add click handler for tab name (switch/toggle tab)
    name_el.onclick = docs.wrap(on_tab_name_click, get_doc_content)

    async function on_tab_name_click () {
      if (_) {
        const head = [by, to, mid++]
        const refs = {}
        const data = {
          type: 'tab',
          sid: opts.sid
        }
        _.up({ head, refs, type: 'ui_focus', data })
        const head2 = [by, to, mid++]
        _.up({ head: head2, refs, type: 'tab_name_clicked', data: { id, name } })
      }
    }

    async function get_doc_content () {
      const doc_file = await drive.get('docs/README.md')
      return doc_file && doc_file.raw ? doc_file.raw : 'No documentation available'
    }

    // Add click handler for close button
    close_btn.onclick = docs.wrap(on_tab_close_click, get_doc_content)

    async function on_tab_close_click (e) {
      e.stopPropagation()
      if (_) {
        const head = [by, to, mid++]
        const refs = {}
        const data = {
          type: 'tab',
          sid: opts.sid
        }
        _.up({ head, refs, type: 'ui_focus', data })
        const head2 = [by, to, mid++]
        _.up({ head: head2, refs, type: 'tab_close_clicked', data: { id, name } })
      }
    }

    entries.appendChild(el)
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init) {
      variables.forEach(create_btn)
      init = true
    } else {
      // TODO: Here we can handle drive updates
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }
  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }
  function inject (data) { style.innerHTML = data.join('\n') }

  function onvariables (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    variables = vars
  }

  function iconject (data) { dricons = data }

  function update_scroll_position () {
    // TODO
  }

  function onscroll (data) {
    setTimeout(apply_scroll_position, 200)
    function apply_scroll_position () {
      if (entries) {
        entries.scrollLeft = data
      }
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: {
        $: ''
      }
    }
  }
  function fallback_instance () {
    return {
      _: {
        DOCS: {
          0: ''
        }
      },
      drive: {
        'icons/': {
          'cross.svg': {
            $ref: 'cross.svg'
          },
          '1.svg': {
            $ref: 'icon.svg'
          },
          '2.svg': {
            $ref: 'icon.svg'
          },
          '3.svg': {
            $ref: 'icon.svg'
          }
        },
        'actions/': {
          'commands.json': {
            raw: JSON.stringify([
              {
                name: 'New Tab',
                icon: 'plus',
                status: {
                  pinned: true,
                  default: true
                },
                steps: [
                  { name: 'Enter Tab Name', type: 'optional', is_completed: false, component: 'form_input', status: 'default', data: '' }
                ]
              },
              {
                name: 'Duplicate Tab',
                icon: 'copy',
                status: {
                  pinned: false,
                  default: false
                },
                steps: [
                  { name: 'Select Tab to Duplicate', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
                  { name: 'Enter New Tab Name', type: 'optional', is_completed: false, component: 'form_input', status: 'default', data: '' }
                ]
              },
              {
                name: 'Close Tab',
                icon: 'close',
                status: {
                  pinned: false,
                  default: true
                },
                steps: [
                  { name: 'Select Tab to Close', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
                  { name: 'Confirm Close', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' }
                ]
              }
            ])
          }
        },
        'variables/': {
          'tabs.json': {
            $ref: 'tabs.json'
          }
        },
        'scroll/': {
          'position.json': {
            raw: '100'
          }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        },
        'style/': {
          'theme.css': {
            $ref: 'style.css'
          }
        }
      }
    }
  }
}
