// --- Main Export ---
// Usage: const docs = DOCS(__filename)(opts.sid)
//        docs.wrap(handler, docContent)
// Admin: Only first caller (root module) gets admin API

module.exports = function DOCS (filename) {
  return function (sid) { return create_context(filename, sid) }
}

const scope = typeof window !== 'undefined' ? window : global

if (!scope.__DOCS_GLOBAL_STATE__) {
  scope.__DOCS_GLOBAL_STATE__ = {
    docs_mode_active: false,
    docs_mode_listeners: [],
    doc_display_callback: null,
    action_registry: new Map()
  }
}

const state = scope.__DOCS_GLOBAL_STATE__

// --- Static Methods (called as DOCS.method()) ---
// Exported via DOCS admin API (only available to first caller)
function set_docs_mode (active) {
  state.docs_mode_active = active
  state.docs_mode_listeners.forEach(notify_docs_mode_listener)

  function notify_docs_mode_listener (listener) { listener(active) }
}

function get_docs_mode () { return state.docs_mode_active }

function on_docs_mode_change (listener) {
  state.docs_mode_listeners.push(listener)
  return unsubscribe_docs_mode_change

  function unsubscribe_docs_mode_change () { state.docs_mode_listeners = state.docs_mode_listeners.filter(is_other_listener) }
  function is_other_listener (current_listener) { return current_listener !== listener }
}

function set_doc_display_handler (callback) { state.doc_display_callback = callback }

function get_actions (sid) {
  const actions = state.action_registry.get(sid) || []
  if (actions.length === 0) throw new Error('DOCS: No actions registered for SID ' + sid)
  return actions
}

function list_registered () { return Array.from(state.action_registry.keys()) }

// --- Internal Helpers ---

function verify_actions (actions) {
  if (!Array.isArray(actions)) throw new Error('DOCS: Actions must be array')
  actions.forEach(validate_action)

  function validate_action (action, i) {
    if (!action.name || typeof action.name !== 'string') throw new Error(`DOCS: Action[${i}] Invalid 'name'`)
    if (!action.icon || typeof action.icon !== 'string') throw new Error(`DOCS: Action[${i}] Invalid 'icon'`)
    if (!action.status || typeof action.status !== 'object') throw new Error(`DOCS: Action[${i}] Invalid 'status'`)
    if (!action.steps || !Array.isArray(action.steps)) throw new Error(`DOCS: Action[${i}] Invalid 'steps'`)
  }
}

async function display_doc (content, sid) {
  let resolved_content = content
  if (typeof content === 'function') {
    resolved_content = await content()
  } else if (content && typeof content.then === 'function') {
    resolved_content = await content
  }

  if (state.doc_display_callback) {
    state.doc_display_callback({ content: resolved_content || 'No documentation available', sid })
  }
}

function create_sys_api (meta) {
  function is_docs_mode () { return state.docs_mode_active }

  function get_doc () { return meta.doc || 'No documentation available' }

  function get_meta () { return { ...meta } }

  function show_doc () { return display_doc(meta.doc || 'No documentation available', meta.sid) }

  return {
    is_docs_mode,
    get_doc,
    get_meta,
    show_doc
  }
}

// --- Instance Methods (called as docs.method()) ---

function wrap (handler, meta = {}, make_sys = create_sys_api) {
  const sys = make_sys(meta)

  return async function wrapped_handler (event) {
    if (sys.is_docs_mode()) {
      if (event && event.preventDefault) {
        event.preventDefault()
        event.stopPropagation()
      }
      sys.show_doc()
      return
    }
    return handler.call(this, event, sys)
  }
}

function wrap_isolated (handler_string, meta = {}) {
  try {
    const params = 'meta, make_sys'
    const source = `(${wrap.toString()})(${handler_string}, ${params})`
    const isolated_fn = new Function(params, source)(meta, create_sys_api)
    return isolated_fn
  } catch (err) {
    console.error('handler function is not allowed to access closure scope', err)
    return wrap(noop_handler, meta)
  }

  function noop_handler () {}
}

function hook (dom, meta = {}) {
  if (!dom) return dom

  const proto = Object.getPrototypeOf(Object.getPrototypeOf(dom))
  if (!proto) return dom

  Object.keys(proto).forEach(hook_event_handler)

  function hook_event_handler (key) {
    if (key.startsWith('on') && typeof dom[key] === 'function') {
      const original = dom[key]
      dom[key] = wrap(original, { ...meta, event_type: key })
    }
  }

  return dom
}

// --- Context Factory (creates instance with component scope) ---

function register_actions (sid, actions) {
  verify_actions(actions)
  state.action_registry.set(sid, actions)
}

let admin = true
function create_context (filename, sid) {
  const api = {
    wrap: wrap_with_component,
    wrap_isolated: wrap_isolated_with_component,
    hook: hook_with_component,
    get_docs_mode,
    on_docs_mode_change,
    register_actions: register_component_actions
  }
  const context = admin ? (admin = false, Object.assign({ admin: { set_docs_mode, set_doc_display_handler, get_actions, list_registered } }, api)) : api
  return context

  function wrap_with_component (handler, doc) { return wrap(handler, { doc, sid, component: filename }) }
  function wrap_isolated_with_component (handler_string, doc) { return wrap_isolated(handler_string, { doc, sid, component: filename }) }
  function hook_with_component (dom, doc) { return hook(dom, { doc, sid, component: filename }) }
  function register_component_actions (actions) { return register_actions(sid, actions) }
}
