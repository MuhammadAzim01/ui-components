// --- Main Export ---
// Usage: const docs = DOCS(__filename)(opts.sid)
//        docs.wrap(handler, docContent)

module.exports = function DOCS (filename) {
  return function (sid) {
    return create_context(filename, sid)
  }
}

// Static methods (called as DOCS.method())
module.exports.set_docs_mode = set_docs_mode
module.exports.get_docs_mode = get_docs_mode
module.exports.on_docs_mode_change = on_docs_mode_change
module.exports.set_doc_display_handler = set_doc_display_handler

const scope = typeof window !== 'undefined' ? window : global

if (!scope.__DOCS_GLOBAL_STATE__) {
  scope.__DOCS_GLOBAL_STATE__ = {
    docs_mode_active: false,
    docs_mode_listeners: [],
    doc_display_callback: null
  }
}

const state = scope.__DOCS_GLOBAL_STATE__

// --- Static Methods (called as DOCS.method()) ---

function set_docs_mode (active) {
  state.docs_mode_active = active
  state.docs_mode_listeners.forEach(listener => listener(active))
}

function get_docs_mode () {
  return state.docs_mode_active
}

function on_docs_mode_change (listener) {
  state.docs_mode_listeners.push(listener)
  return () => {
    state.docs_mode_listeners = state.docs_mode_listeners.filter(l => l !== listener)
  }
}

function set_doc_display_handler (callback) {
  state.doc_display_callback = callback
}

// --- Internal Helpers ---

async function display_doc (content, sid) {
  let resolved_content = content
  if (typeof content === 'function') {
    resolved_content = await content()
  } else if (content && typeof content.then === 'function') {
    resolved_content = await content
  }
  
  if (state.doc_display_callback) {
    state.doc_display_callback({ content: resolved_content || 'No documentation available', sid })
  }
}

function create_sys_api (meta) {
  return {
    is_docs_mode: () => state.docs_mode_active,
    get_doc: () => meta.doc || 'No documentation available',
    get_meta: () => ({ ...meta }),
    show_doc: () => display_doc(meta.doc || 'No documentation available', meta.sid)
  }
}

// --- Instance Methods (called as docs.method()) ---

function wrap (handler, meta = {}) {
  const sys = create_sys_api(meta)
  
  return async function wrapped_handler (event) {
    if (state.docs_mode_active) {
      if (event && event.preventDefault) {
        event.preventDefault()
        event.stopPropagation()
      }
      await display_doc(meta.doc || 'No documentation available', meta.sid)
      return
    }
    return handler.call(this, event, sys)
  }
}

function wrap_isolated (handler_string, meta = {}) {
  const sys = create_sys_api(meta)
  
  try {
    const isolated_fn = new Function('sys', `return function isolated_handler (event) { 
      if (sys.is_docs_mode()) {
        if (event && event.preventDefault) {
          event.preventDefault()
          event.stopPropagation()
        }
        sys.show_doc()
        return
      }
      return (${handler_string})(event, sys)
    }`)(sys)
    
    return isolated_fn
  } catch (err) {
    console.error('DOCS.wrap_isolated failed:', err)
    return wrap(() => {}, meta)
  }
}

function hook (dom, meta = {}) {
  if (!dom) return dom
  
  const proto = Object.getPrototypeOf(Object.getPrototypeOf(dom))
  if (!proto) return dom
  
  Object.keys(proto).forEach(key => {
    if (key.startsWith('on') && typeof dom[key] === 'function') {
      const original = dom[key]
      dom[key] = wrap(original, { ...meta, event_type: key })
    }
  })
  
  return dom
}

// --- Context Factory (creates instance with component scope) ---

function create_context (filename, sid) {
  return {
    wrap: (handler, doc) => wrap(handler, { doc, sid, component: filename }),
    wrap_isolated: (handler_string, doc) => wrap_isolated(handler_string, { doc, sid, component: filename }),
    hook: (dom, doc) => hook(dom, { doc, sid, component: filename }),
    get_docs_mode,
    on_docs_mode_change
  }
}

