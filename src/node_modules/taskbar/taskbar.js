const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const manager = require('manager')
const tabsbar = require('tabsbar')

module.exports = taskbar

async function taskbar (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  // const ids = opts.ids || {}
  // const by = id
  // const to = ids.up || 'parent'

  const on = {
    style: inject
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
  <div class="taskbar-container main">
    <div class="manager-slot"></div>
    <div class="tabsbar-slot"></div>
  </div>
  <style>
  </style>`
  const style = shadow.querySelector('style')
  const manager_slot = shadow.querySelector('.manager-slot')
  const tabsbar_slot = shadow.querySelector('.tabsbar-slot')

  const subs = await sdb.watch(onbatch)
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
    _ = { up: send, manager: null, tabsbar: null }
  }
  const manager_el = protocol ? await manager({ ...subs[0], ids: { up: id } }, manager_protocol) : await manager(subs[0])
  manager_el.classList.add('replaced-manager')
  manager_slot.replaceWith(manager_el)

  const tabsbar_el = protocol ? await tabsbar({ ...subs[1], ids: { up: id } }, tabsbar_protocol) : await tabsbar(subs[1])
  tabsbar_el.classList.add('replaced-tabsbar')
  tabsbar_slot.replaceWith(tabsbar_el)

  return el

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail (data, type) { throw new Error('invalid message', { cause: { data, type } }) }

  function inject (data) {
    style.innerHTML = data.join('\n')
  }

  // ---------
  // PROTOCOLS
  // ---------
  function manager_protocol (send) {
    _.manager = send
    return on
    function on (msg) {
      _.up(msg)
    }
  }

  function tabsbar_protocol (send) {
    _.tabsbar = send
    return on
    function on (msg) {
      _.up(msg)
    }
  }

  function onmessage (msg) {
    const { type } = msg
    switch (type) {
    case 'tab_name_clicked':
    case 'tab_close_clicked':
      _.up(msg)
      break
    default:
      if (_.manager) {
        _.manager(msg)
      }
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      manager: {
        $: ''
      },
      tabsbar: {
        $: ''
      }
    }
  }

  function fallback_instance () {
    return {
      _: {
        manager: {
          0: '',
          mapping: {
            icons: 'icons',
            style: 'style'
          }
        },
        tabsbar: {
          0: '',
          mapping: {
            icons: 'icons',
            style: 'style'
          }
        }
      },
      drive: {
        'style/': {
          'theme.css': {
            raw: `
              .taskbar-container {
                display: flex;
                background: #2d2d2d;
                column-gap: 1px;
              }
              .replaced-tabsbar {
                display: flex;
                flex: auto;
              }
              .replaced-manager {
                display: flex;
              }
              @media (max-width: 768px) {
                .taskbar-container {
                  flex-direction: column;
                }
              }
            `
          }
        }
      }
    }
  }
}
