const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = tile_split_choice
async function tile_split_choice (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject,
    data: ondata
  }

  let current_step = null
  let mid = 0
  let _ = { up: null }


  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="tile-split-chooser">
    <div class="title">Split Tile</div>
    <div class="choices">
      <button class="choice-btn" data-choice="up">
        <span class="arrow up"></span>
        <span class="label">Up</span>
      </button>
      <button class="choice-btn" data-choice="left">
        <span class="arrow left"></span>
        <span class="label">Left</span>
      </button>
      <button class="choice-btn" data-choice="right">
        <span class="arrow right"></span>
        <span class="label">Right</span>
      </button>
      <button class="choice-btn" data-choice="down">
        <span class="arrow down"></span>
        <span class="label">Down</span>
      </button>
    </div>
    <div class="hint">Choose direction to split the tile</div>
  </div>
  <style></style>
  `
  const style = shadow.querySelector('style')
  const buttons = Array.from(shadow.querySelectorAll('.choice-btn'))

  buttons.forEach(btn => btn.addEventListener('click', on_choice_click))

  await sdb.watch(onbatch)
  
  const parent_handler = {
    step_data,
    reset_data
  }

  // register protocol after handlers are defined to avoid TDZ issues
  if (protocol) {
    const send = protocol(onmessage)
    _ = { up: send }
  }

  return el

  function onmessage ({ type, data }) {
    const handler = parent_handler[type] || fail
    handler(data, type)
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const func = on[type] || fail
      func(data, type)
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }

  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }

  function inject (data) {
    style.replaceChildren(create_style_element())

    function create_style_element () {
      const style_el = document.createElement('style')
      style_el.textContent = data[0]
      return style_el
    }
  }

  function ondata (data) {
    // support persisted/default choice if present
    if (data.length > 0 && data[0] && data[0].choice) {
      highlight_choice(String(data[0].choice))
    }
  }

  function step_data (data) {
    current_step = data
  }

  function reset_data () {
    // nothing for now
  }

  async function on_choice_click (ev) {
    const choice = ev.currentTarget.getAttribute('data-choice')
    await drive.put('data/tile_split_choice.json', { choice })
    highlight_choice(choice)
    const head = [by, to, mid++]
    const refs = {}
    _.up({ head, refs, type: 'action_submitted', data: { value: choice, index: current_step?.index ?? 0 } })
  }

  function highlight_choice (choice) {
    buttons.forEach(b => {
      const isActive = b.getAttribute('data-choice') === choice
      b.classList.toggle('active', isActive)
      b.setAttribute('aria-pressed', isActive ? 'true' : 'false')
      if (isActive) {
        b.style.background = 'linear-gradient(180deg, rgba(103,195,255,0.06), rgba(103,195,255,0.02))'
        b.style.boxShadow = '0 12px 36px rgba(103,195,255,0.16)'
        b.style.borderColor = 'rgba(103,195,255,0.36)'
        b.style.transform = 'translateY(-2px) scale(1.01)'
      } else {
        b.style.background = ''
        b.style.boxShadow = ''
        b.style.borderColor = ''
        b.style.transform = ''
      }
    })
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: { $: '' }
    }
  }

  function fallback_instance () {
    return {
      _: { DOCS: { 0: '' } },
      drive: {
        'style/': {
          'tile_split_choice.css': { $ref: 'tile_split_choice.css' }
        },
        'data/': {
          'tile_split_choice.json': { raw: { choice: null } }
        },
        'docs/': { 'README.md': { $ref: 'README.md' } }
      }
    }
  }
}
