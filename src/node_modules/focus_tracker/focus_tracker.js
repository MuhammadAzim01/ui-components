const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)

module.exports = focus_tracker

async function focus_tracker (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    focused
  }
  // Keep track of the last focused element
  let last_focused = null
  let mid = 0
  let _ = null
  let docs_mode_active = false

  if (protocol) {
    const send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }

  function onmessage (msg) {
    const { type, data } = msg
    if (type === 'ui_focus_docs') {
      // Direct docs request from component - route to control_unit
      const head = [by, to, mid++]
      const refs = msg.head ? { cause: msg.head } : {}
      _.up({ head, refs, type: 'tracked_doc', data })
    } else if (type === 'ui_focus') {
      drive.put('focused/current.json', { value: data })
    } else if (type === 'docs_toggle') {
      docs_mode_active = data?.active || false
    }
  }

  await sdb.watch(onbatch)

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }
  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }
  function focused (data) {
    const tmp = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    if (_ && last_focused !== tmp.value) {
      const head = [by, to, mid++]
      const refs = {}
      _.up({ head, refs, type: 'focused_app_changed', data: { focused_app: tmp.value } })
    }

    last_focused = tmp.value
  }
}

function fallback_module () {
  return {
    api: fallback_instance
  }
  function fallback_instance () {
    return {
      drive: {
        'focused/': {
          'current.json': {
            raw: { value: 'default' }
          }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        }
      }
    }
  }
}
