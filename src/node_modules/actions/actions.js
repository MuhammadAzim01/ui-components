const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = actions

async function actions (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject,
    actions: onactions,
    icons: iconject,
    hardcons: onhardcons
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
  <div class="actions-container main">
    <div class="actions-menu"></div>
  </div>
  <style>
  </style>`
  const style = shadow.querySelector('style')
  const actions_menu = shadow.querySelector('.actions-menu')

  let init = false
  let mid = 0
  let actions = []
  let icons = {}
  let hardcons = {}
  const docs = DOCS(__filename)(opts.sid)
  const on_message = {
    filter_actions: handle_filter_actions,
    send_selected_action: handle_send_selected_action,
    load_actions: handle_load_actions_message,
    update_actions_for_app: handle_update_actions_for_app_message
  }

  await sdb.watch(onbatch)
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(onmessage)
    _ = { up: send }
  }

  return el

  function onmessage (msg) {
    const handler = on_message[msg.type] || onmessage_fail
    handler(msg)
  }

  function handle_filter_actions (msg) { filter(msg.data) }
  function handle_send_selected_action (msg) { send_selected_action(msg) }
  function handle_load_actions_message (msg) { handle_load_actions(msg.data) }
  function handle_update_actions_for_app_message (msg) { update_actions_for_app(msg.data) }
  function onmessage_fail (msg) { fail(msg.data, msg.type) }
  function handle_load_actions (data) {
    const converted_actions = Object.keys(data).map(convert_action_key)
    actions = converted_actions
    create_actions_menu()

    function convert_action_key (action_key) {
      return {
        action: action_key,
        pinned: false,
        default: true,
        icon: 'file'
      }
    }
  }

  function send_selected_action (msg) {
    const action_data = msg && msg.data && msg.data.data ? msg.data.data : msg && msg.data ? msg.data : undefined

    const head = [by, to, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.up({
      head,
      refs,
      type: 'selected_action',
      data: action_data
    })
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init) {
      create_actions_menu()
      init = true
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }

  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }

  function inject (data) { style.innerHTML = data.join('\n') }
  function iconject (data) { icons = data }

  function onhardcons (data) {
    console.log('Hardcons data:', opts.sid, data)
    hardcons = {
      pin: data[0],
      unpin: data[1],
      default: data[2],
      undefault: data[3]
    }
  }

  function onactions (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    actions = vars
    create_actions_menu()
  }

  function create_actions_menu () {
    actions_menu.replaceChildren()
    actions.forEach(create_action_item)
  }

  function create_action_item (action_data, index) {
    const action_item = document.createElement('div')
    action_item.classList.add('action-item')

    const this_icon = icons[index] || icons[0]
    action_item.innerHTML = `
    <div class="action-icon">${this_icon}</div>
    <div class="action-name">${action_data.action}</div>
    <div class="action-pin">${action_data.pin ? hardcons.pin : hardcons.unpin}</div>
    <div class="action-default">${action_data.default ? hardcons.default : hardcons.undefault}</div>`
    action_item.onclick = docs.wrap(on_action_item_click, get_doc_content)
    actions_menu.appendChild(action_item)

    function on_action_item_click () { send_selected_action({ data: action_data.action }) }
    async function get_doc_content () {
      const doc_file = await drive.get('docs/README.md')
      return doc_file?.raw || 'No documentation available'
    }
  }

  function filter (search_term) {
    const items = shadow.querySelectorAll('.action-item')
    items.forEach(update_item_visibility)

    function update_item_visibility (item) {
      const action_name = item.children[1].textContent.toLowerCase()
      const matches = action_name.includes(search_term.toLowerCase())
      item.style.display = matches ? 'flex' : 'none'
    }
  }

  async function update_actions_for_app (data) {
    if (data) {
      drive.put('actions/commands.json', data)
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: {
        $: ''
      }
    }
  }

  function fallback_instance () {
    return {
      _: {
        DOCS: {
          0: ''
        }
      },
      drive: {
        'actions/': {
          'commands.json': {
            raw: JSON.stringify([])
          }
        },
        'icons/': {
          'file.svg': {
            $ref: 'icon.svg'
          },
          'folder.svg': {
            $ref: 'icon.svg'
          },
          'save.svg': {
            $ref: 'icon.svg'
          },
          'gear.svg': {
            $ref: 'icon.svg'
          },
          'help.svg': {
            $ref: 'icon.svg'
          },
          'terminal.svg': {
            $ref: 'icon.svg'
          },
          'search.svg': {
            $ref: 'icon.svg'
          }
        },
        'hardcons/': {
          'pin.svg': {
            $ref: 'pin.svg'
          },
          'unpin.svg': {
            $ref: 'unpin.svg'
          },
          'default.svg': {
            $ref: 'default.svg'
          },
          'undefault.svg': {
            $ref: 'undefault.svg'
          }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        },
        'style/': {
          'theme.css': {
            raw: `
              .actions-container {
                position: relative;
                background: #202124;
                border: 1px solid #3c3c3c;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                max-height: 200px;
                width: 100%;
                overflow-y: auto;
                color: #e8eaed;
              }
              
              .actions-menu {
                padding: 8px 0;
              }
              
              .action-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 16px;
                cursor: pointer;
                border-bottom: 1px solid #3c3c3c;
                transition: background-color 0.2s ease;
              }
              
              .action-item:hover {
                background-color: #2d2f31;
              }
              
              .action-item:last-child {
                border-bottom: none;
              }
              
              .action-icon {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 20px;
                height: 20px;
                color: #a6a6a6;
              }
              
              .action-name {
                flex: 1;
                font-size: 14px;
                color: #e8eaed;
              }
              
              .action-pin .action-default{
                display: flex;
                align-items: center;
                justify-content: center;
                width: 16px;
                height: 16px;
                font-size: 12px;
                opacity: 0.7;
                color: #a6a6a6;
              }
              
              svg {
                width: 16px;
                height: 16px;
              }
            `
          }
        }
      }
    }
  }
}
