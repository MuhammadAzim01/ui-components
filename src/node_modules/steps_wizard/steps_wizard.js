const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

module.exports = steps_wizard

async function steps_wizard (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject
  }

  let variables = []
  let currentActiveStep = 0
  let mid = 0
  const docs = DOCS(__filename)(opts.sid)

  let _ = { up: null }
  if (protocol) {
    const send = protocol(onmessage)
    _ = { up: send }
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="steps-wizard main">
    <div class="steps-container">
      <div class="steps-slot"></div>
    </div>
  </div>
  <style>
  </style>
  `

  const style = shadow.querySelector('style')
  const steps_entries = shadow.querySelector('.steps-slot')
  await sdb.watch(onbatch)

  // for demo purpose
  render_steps([
    { name: 'Optional Step', type: 'optional', is_completed: false, component: 'form_input', status: 'default', data: '' },
    { name: 'Step 2 testingasadasdadasdasdaasdasdsassss', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
    { name: 'Step 3', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
    { name: 'Step 4', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
    { name: 'Step 5', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' }
  ])

  return el

  function onmessage ({ type, data }) {
    // docs_toggle handled globally by DOCS module
    if (type === 'init_data') {
      // If data contains steps from the new action format, use them
      if (data) {
        render_steps(data)
      } else {
        // Fallback to default steps
        variables = [
          { name: 'Optional Step', type: 'optional', is_completed: false, component: 'form_input', status: 'default', data: '' },
          { name: 'Step 2 testing', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: 'asdasd' },
          { name: 'Step 3', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
          { name: 'Step 4', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' },
          { name: 'Step 5', type: 'mandatory', is_completed: false, component: 'form_input', status: 'default', data: '' }
        ]
        render_steps(variables)
      }
    }
  }

  function render_steps (steps) {
    if (!steps) { return }

    steps_entries.innerHTML = ''

    steps.forEach(create_step_button)

    function create_step_button (step, index) {
      const btn = document.createElement('button')
      btn.className = 'step-button'
      btn.textContent = step.name + (step.type === 'optional' ? ' *' : '')
      btn.title = btn.textContent
      btn.setAttribute('data-step', index + 1)

      const accessible = can_access(index, steps)

      let status = 'default'
      if (!accessible) status = 'disabled'
      else if (step.is_completed) status = 'completed'
      else if (step.status === 'error') status = 'error'
      else if (step.type === 'optional') status = 'optional'

      btn.classList.add(`step-${status}`)

      if (index === currentActiveStep - 1 && index > 0) {
        btn.classList.add('back')
      }
      if (index === currentActiveStep + 1 && index < steps.length - 1) {
        btn.classList.add('next')
      }
      if (index === currentActiveStep) {
        btn.classList.add('active')
      }

      btn.onclick = docs.wrap(on_step_click, get_doc_content)

      async function on_step_click () {
        const head = [by, to, mid++]
        const refs = {}
        console.log('Clicked:', step)
        currentActiveStep = index
        center_step(btn)
        render_steps(steps)
        _ && _.up({ head, refs, type: 'step_clicked', data: { ...step, index, total_steps: steps.length, is_accessible: accessible } })
      }

      async function get_doc_content () {
        const doc_file = await drive.get('docs/README.md')
        return doc_file && doc_file.raw ? doc_file.raw : 'No documentation available'
      }

      steps_entries.appendChild(btn)
    }
  }

  function center_step (step_button) {
    const container_width = steps_entries.clientWidth
    const step_left = step_button.offsetLeft
    const step_width = step_button.offsetWidth

    const center_position = step_left - (container_width / 2) + (step_width / 2)

    steps_entries.scrollTo({
      left: center_position,
      behavior: 'smooth'
    })
  }

  function can_access (index, steps) {
    for (let i = 0; i < index; i++) {
      if (!steps[i].is_completed && steps[i].type !== 'optional') {
        return false
      }
    }

    return true
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const func = on[type] || fail
      func(data, type)
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }
  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }

  function inject (data) {
    style.replaceChildren(create_style_element())

    function create_style_element () {
      const style_el = document.createElement('style')
      style_el.textContent = data[0]
      return style_el
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      DOCS: {
        $: ''
      }
    }
  }

  function fallback_instance () {
    return {
      _: {
        DOCS: {
          0: ''
        }
      },
      drive: {
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        },
        'style/': {
          'stepswizard.css': {
            $ref: 'stepswizard.css'
          }
        }
      }
    }
  }
}
