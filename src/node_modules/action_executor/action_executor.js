const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)

const program = require('program')
const steps_wizard = require('steps_wizard')

const { form_input, input_test } = program

const component_modules = {
  form_input,
  input_test
  // Add more form input components here if needed
}

module.exports = action_executor

async function action_executor (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  const on = {
    style: inject
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="container main">
    <program></program>
    <form-input></form-input>
    <steps-wizard></steps-wizard>
  </div>
  <style>
  </style>`

  const style = shadow.querySelector('style')
  const program_placeholder = shadow.querySelector('program')
  const form_input_placeholder = shadow.querySelector('form-input')
  const steps_wizard_placeholder = shadow.querySelector('steps-wizard')

  const subs = await sdb.watch(onbatch)

  const _ = {
    up: null,
    send_program: null,
    send_steps_wizard: null,
    send_form_input: {}
  }
  let all_data = null
  let variables = []
  let selected_action = null
  let mid = 0

  if (protocol) {
    const send = protocol(msg => onmessage(msg))
    _.up = send
  }

  const program_sid = subs[0].sid
  const steps_wizard_sid = subs[1].sid
  const form_input_sids = {}

  // dynamic form input component SIDs
  for (const [index, [component_name]] of Object.entries(component_modules).entries()) {
    const final_index = index + 2
    form_input_sids[component_name] = subs[final_index].sid
  }

  const program_el = protocol ? await program({ ...subs[0], ids: { up: id } }, program_protocol) : await program({ ...subs[0], ids: { up: id } })
  program_el.classList.add('program-bar', 'hide')
  program_placeholder.replaceWith(program_el)

  const steps_wizard_el = protocol ? await steps_wizard({ ...subs[1], ids: { up: id } }, steps_wizard_protocol) : await steps_wizard({ ...subs[1], ids: { up: id } })
  steps_wizard_el.classList.add('steps-wizard-bar', 'hide')
  steps_wizard_placeholder.replaceWith(steps_wizard_el)

  const form_input_elements = {}

  for (const [index, [component_name, component_fn]] of Object.entries(component_modules).entries()) {
    const final_index = index + 2
    const element = await component_fn({ ...subs[final_index], ids: { up: id } }, form_input_protocol(component_name))
    element.classList.add('form-inputs', 'hide')
    form_input_elements[component_name] = element
    form_input_placeholder.parentNode.insertBefore(element, form_input_placeholder)
  }

  form_input_placeholder.remove()

  const parent_handler = {
    update_steps_wizard_for_app,
    load_actions,
    action_submitted,
    update_data,
    activate_steps_wizard,
    form_data,
    render_form,
    selected_action: parent__selected_action,
    clean_up
  }

  return el

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }
  function fail (data, type) { console.warn('Unknown message type:', type, data) }

  function inject (data) {
    style.innerHTML = data.join('\n')
  }

  // --- Toggle Views ---
  function toggle_view (el, show) {
    el.classList.toggle('hide', !show)
  }

  function steps_toggle_view (display) {
    toggle_view(steps_wizard_el, display === 'block')
  }

  function render_form_component (component_name) {
    for (const name in form_input_elements) {
      toggle_view(form_input_elements[name], name === component_name)
    }
  }

  // -------------------------------
  // Protocol: program
  // -------------------------------

  function program_protocol (send) {
    _.send_program = send

    const program_handlers = {
      load_actions: program__load_actions
    }
    return function on (msg) {
      const { type, data } = msg
      const handler = program_handlers[type] || fail
      handler(data, type, msg)
    }
  }

  function program__load_actions (data, type, msg) {
    variables = data
    const head = [by, to, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.up && _.up({ head, refs, type, data })
  }

  // -------------------------------
  // Protocol: steps wizard
  // -------------------------------

  function steps_wizard_protocol (send) {
    _.send_steps_wizard = send

    const steps_handlers = {
      step_clicked: steps_wizard__step_clicked
    }

    return function on (msg) {
      const { type } = msg
      const handler = steps_handlers[type]
      if (handler) handler(msg)
      else _.up && _.up(msg)
    }
  }

  function steps_wizard__step_clicked (msg) {
    const { data } = msg
    const head = [by, to, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.up && _.up({ head, refs, type: 'step_clicked', data })
  }

  // -------------------------------
  // Protocol: form input
  // -------------------------------

  function form_input_protocol (component_name) {
    return function (send) {
      _.send_form_input[component_name] = send

      const form_input_handlers = {
        action_submitted: form__action_submitted,
        action_incomplete: form__action_incomplete
      }

      return on
      function on (msg) {
        const { type, data } = msg
        const handler = form_input_handlers[type] || fail
        handler(data, type, msg)
      }
    }
  }

  function form__action_submitted (data, type, msg) {
    console.log('action_executor.on_form_submitted', data, variables, selected_action)
    const step = variables[selected_action] && data && data.index !== undefined ? variables[selected_action][data.index] : undefined
    Object.assign(step, {
      is_completed: true,
      status: 'completed',
      data: data.value
    })
    const refs = msg.head ? { cause: msg.head } : {}
    const head_to_program = [by, program_sid, mid++]
    _.send_program && _.send_program({ head: head_to_program, refs, type: 'update_data', data: variables })

    const head_to_steps = [by, steps_wizard_sid, mid++]
    _.send_steps_wizard && _.send_steps_wizard({ head: head_to_steps, type: 'init_data', data: variables[selected_action] })

    if (variables[selected_action] && variables[selected_action][variables[selected_action].length - 1] && variables[selected_action][variables[selected_action].length - 1].is_completed) {
      const head = [by, to, mid++]
      _.up && _.up({ head, refs, type: 'show_submit_btn' })
    }
  }

  function form__action_incomplete (data, type, msg) {
    console.log('action_executor.on_form_incomplete', data, variables, selected_action)
    const step = variables[selected_action] && data && data.index !== undefined ? variables[selected_action][data.index] : undefined

    if (!step.is_completed) return

    Object.assign(step, {
      is_completed: false,
      status: 'error',
      data: data && data.value !== undefined ? data.value : undefined
    })
    const refs = msg.head ? { cause: msg.head } : {}
    const head_to_program = [by, program_sid, mid++]
    _.send_program && _.send_program({ head: head_to_program, refs, type: 'update_data', data: variables })

    const head_to_steps = [by, steps_wizard_sid, mid++]
    _.send_steps_wizard && _.send_steps_wizard({ head: head_to_steps, type: 'init_data', data: variables[selected_action] })

    const head = [by, to, mid++]
    _.up && _.up({ head, refs, type: 'hide_submit_btn' })
  }

  // -------------------------------
  // onmessage from parent
  // -------------------------------

  function onmessage (msg) {
    const { type } = msg
    if (type === 'docs_toggle') {
      _.send_steps_wizard && _.send_steps_wizard(msg)
      for (const name in _.send_form_input) {
        _.send_form_input[name](msg)
      }
    } else {
      parent_handler[type] && parent_handler[type](msg)
    }
  }

  function update_steps_wizard_for_app (msg) {
    const { data } = msg
    all_data = data
  }

  function load_actions (msg) {
    variables = msg.data
    const { data, type } = msg
    const head = [by, program_sid, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.send_program && _.send_program({ head, refs, type, data })
  }

  function action_submitted (msg) {
    const { data } = msg
    const head = [by, program_sid, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.send_program && _.send_program({ head, refs, type: 'display_result', data })
  }

  function render_form (msg) {
    const { data } = msg
    render_form_component(data.component)
    const send = _.send_form_input[data.component]
    if (send) {
      const head = [by, form_input_sids[data.component], mid++]
      const refs = msg.head ? { cause: msg.head } : {}
      send({ head, refs, type: 'step_data', data })
    }
  }

  function parent__selected_action (msg) {
    selected_action = msg.data
  }

  function update_data (msg) {
    const { data, type } = msg
    variables = data
    const head = [by, program_sid, mid++]
    const refs = msg.head ? { cause: msg.head } : {}
    _.send_program && _.send_program({ head, refs, type, data })
  }

  function activate_steps_wizard (msg) {
    if (!all_data) return
    const steps_data = all_data.find(action => action.name === msg.data)
    if (!steps_data) return
    steps_toggle_view('block')
    const head_to_steps = [by, steps_wizard_sid, mid++]
    const data = steps_data.steps
    _.send_steps_wizard && _.send_steps_wizard({
      head: head_to_steps,
      refs: {},
      type: 'init_data',
      data: steps_data.steps
    })
  }

  function form_data (msg) {
    // forward init_data to steps_wizard with current action steps
    const { data } = msg
    const head_to_steps = [by, steps_wizard_sid, mid++]
    _.send_steps_wizard && _.send_steps_wizard({ head: head_to_steps, type: 'init_data', data })
  }

  function clean_up (msg) {
    steps_toggle_view('none')
    for (const el of Object.values(form_input_elements)) {
      toggle_view(el, false)
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      program: { $: '' },
      steps_wizard: { $: '' }
    }
  }
  function fallback_instance () {
    return {
      _: {
        program: {
          0: '',
          mapping: {
            style: 'style',
            variables: 'variables',
            docs: 'docs'
          }
        },
        steps_wizard: {
          0: '',
          mapping: {
            style: 'style',
            variables: 'variables',
            docs: 'docs'
          }
        },
        'program>form_input': {
          0: '',
          mapping: {
            style: 'style',
            data: 'data',
            docs: 'docs'
          }
        },
        'program>input_test': {
          0: '',
          mapping: {
            style: 'style',
            data: 'data',
            docs: 'docs'
          },
          DOCS: {
            0: ''
          }
        }
      },
      drive: {
        'style/': {
          'action_executor.css': {
            raw: `
              .container {
                display: flex;
                flex-direction: column;
                width: 100%;
              }
              .program-bar {
                display: flex;
              }
              .form-inputs {
                display: flex;
              }
              .steps-wizard-bar {
                display: flex;
              }
              .hide {
                display: none;
              }
            `
          }
        },
        'variables/': {},
        'data/': {},
        'docs/': {}
      }
    }
  }
}
