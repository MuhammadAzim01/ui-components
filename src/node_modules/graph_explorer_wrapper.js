const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const graph_explorer = require('graph-explorer')

module.exports = wrapper

async function wrapper (opts, protocol) {
  const { sdb } = await get(opts.sid)
  const { drive } = sdb
  const on = {}

  const subs = await sdb.watch(onbatch)
  
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
    _ = { up: send, graph_explorer: null }
  }

  const el = protocol ? await graph_explorer(subs[0], graph_explorer_protocol) : await graph_explorer(subs[0])
  
  return el

  function graph_explorer_protocol (send) {
    _.graph_explorer = send
    return on
    function on ({ type, data }) {
      // graph-explorer to parent
      _.up({ type, data })
    }
  }

  function onmessage ({ type, data }) {
    // parent to graph-explorer
    if (_.graph_explorer) {
      _.graph_explorer({ type, data })
    }
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || (() => {})
      func(data, type)
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      'graph-explorer': {
        $: ''
      }
    }
  }

  function fallback_instance () {
    return {
      _: {
        'graph-explorer': {
          0: '',
          mapping: {
            'style': 'style',
            'runtime': 'runtime',
            'mode': 'mode',
            'flags': 'flags',
            'keybinds': 'keybinds',
            'undo': 'undo'
          }
        }
      },
      drive: {
        'style/': {},
        'runtime/': {},
        'mode/': {},
        'flags/': {},
        'keybinds/': {},
        'undo/': {}
      }
    }
  }
}
