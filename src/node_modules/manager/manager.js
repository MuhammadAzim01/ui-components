const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const DOCS = require('DOCS')

const action_bar = require('action_bar')

module.exports = manager

async function manager (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  // const to = ids.up

  const on = {
    style: inject
  }

  let mid = 0

  let _ = null
  if (protocol) {
    const send = protocol(msg => onmessage(msg))
    _ = { up: send, send_actions_bar: null }
  } else {
    _ = { send_actions_bar: null }
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
    <action-bar></action-bar>
    <style></style>
  `

  const style = shadow.querySelector('style')
  const action_bar_placeholder = shadow.querySelector('action-bar')

  const subs = await sdb.watch(onbatch)

  const action_bar_sid = subs[0].sid

  const action_bar_el = await action_bar({ ...subs[0], ids: { up: id } }, actions_bar_protocol)
  action_bar_el.classList.add('main')
  action_bar_placeholder.replaceWith(action_bar_el)

  return el

  function onmessage (msg) {
    const { type } = msg
    switch (type) {
    case 'docs_toggle':
      _.send_actions_bar?.(msg)
      break
    case 'load_actions':
      const head_to_action_bar_load = [by, action_bar_sid, mid++]
      const load_refs = msg.head ? { cause: msg.head } : {}
      _.send_actions_bar?.({ head: head_to_action_bar_load, refs: load_refs, type: msg.type, data: msg.data })
      break
    case 'step_clicked':
      _.send_actions_bar?.(msg)
      break
    case 'update_quick_actions_for_app':
      const head_to_quick_actions = [by, action_bar_sid, mid++]
      const quick_refs = msg.head ? { cause: msg.head } : {}
      _.send_actions_bar?.({ head: head_to_quick_actions, refs: quick_refs, type, data: msg.data })
      break
    case 'update_quick_actions_input':
      const head_to_action_bar_input = [by, action_bar_sid, mid++]
      const input_refs = msg.head ? { cause: msg.head } : {}
      _.send_actions_bar?.({ head: head_to_action_bar_input, refs: input_refs, type, data: msg.data })
      break
    case 'show_submit_btn':
    case 'hide_submit_btn':
      _.send_actions_bar?.(msg)
      break
    default: // @TODO Handle message types
    }
  }

  // --- Internal Functions ---
  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail (data, type) {
    console.warn('invalid message', { cause: { data, type } })
  }

  function inject (data) {
    style.replaceChildren((() => {
      const style_el = document.createElement('style')
      style_el.textContent = data[0]
      return style_el
    })())
  }

  // -------------------------------
  // Protocol: action bar
  // -------------------------------

  function actions_bar_protocol (send) {
    _.send_actions_bar = send

    const action_bar_handlers = {
      render_form: action_bar__render_form,
      clean_up: action_bar__clean_up,
      action_submitted: action_bar__action_submitted,
      selected_action: action_bar__selected_action,
      activate_steps_wizard: action_bar__activate_steps_wizard
    }

    return function on (msg) {
      if (msg.type === 'console_history_toggle' || msg.type === 'ui_focus' || msg.type === 'display_actions' || msg.type === 'filter_actions') {
        _.up(msg)
        return
      }

      const { type, data } = msg
      const handler = action_bar_handlers[type] || fail
      handler(data, type, msg)
    }
  }

  function action_bar__render_form (data, type, msg) {
    _.up?.(msg)
  }

  function action_bar__action_submitted (data, type, msg) {
    _.up?.(msg)
  }

  function action_bar__selected_action (data, type, msg) {
    _.up?.(msg)
  }

  function action_bar__activate_steps_wizard (data, type, msg) {
    _.up?.(msg)
  }

  function action_bar__clean_up (data, type, msg) {
    _.up?.(msg)
  }
}

// --- Fallback Module ---
function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      action_bar: { $: '' },
      DOCS: { $: '' }
    }
  }

  function fallback_instance () {
    return {
      _: {
        action_bar: {
          0: '',
          mapping: {
            icons: 'icons',
            style: 'style',
            actions: 'actions',
            variables: 'variables',
            hardcons: 'hardcons',
            prefs: 'prefs',
            docs: 'docs'
          }
        }
      },
      drive: {
        'style/': {
          'manager.css': {
            raw: `
              .main {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: flex-start;
                width: 100%;
                height: 100%;
                background: #131315;
              }
              .hide {
                display: none;
              }
            `
          }
        },
        'variables/': {},
        'data/': {},
        'actions/': {},
        'hardcons/': {},
        'prefs/': {},
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        }
      }
    }
  }
}
