const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const graph_explorer = require('graph-explorer')
const graphdb = require('./graphdb')

module.exports = graph_explorer_wrapper

async function graph_explorer_wrapper (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const ids = opts.ids
  if (!ids || !ids.up) {
    throw new Error(`Component ${__filename} requires ids.up to be provided`)
  }
  const by = id
  const to = ids.up

  let db = null
  let latest_entries = null
  const pending_to_graph_explorer = []
  let graph_explorer_sid = null
  let graph_explorer_channel_ready = false
  let graph_explorer_db_ready = false

  // Protocol
  let send_to_graph_explorer = null
  let mid = 0
  const _ = { up: null }

  if (protocol) {
    const send = protocol(onmessage)
    _.up = send
  }

  const on = {
    theme: inject,
    entries: on_entries
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })

  const sheet = new CSSStyleSheet()
  shadow.adoptedStyleSheets = [sheet]

  const subs = await sdb.watch(onbatch)
  graph_explorer_sid = subs[0].sid

  const explorer_el = await graph_explorer(subs[0], graph_explorer_protocol)
  shadow.append(explorer_el)

  return el

  function onmessage (msg) {
    const parent_handlers = {
      execute_step: parent__execute_step,
      set_mode: parent__forward_to_graph_explorer,
      set_search_query: parent__forward_to_graph_explorer,
      select_nodes: parent__forward_to_graph_explorer,
      expand_node: parent__forward_to_graph_explorer,
      collapse_node: parent__forward_to_graph_explorer,
      toggle_node: parent__forward_to_graph_explorer,
      get_selected: parent__forward_to_graph_explorer,
      get_confirmed: parent__forward_to_graph_explorer,
      clear_selection: parent__forward_to_graph_explorer,
      set_flag: parent__forward_to_graph_explorer,
      scroll_to_node: parent__forward_to_graph_explorer,
      docs_toggle: parent__forward_to_graph_explorer
    }
    const handler = parent_handlers[msg.type] || parent__noop
    handler(msg)
  }

  function parent__execute_step (msg) {
    const commands = get_step_commands(msg.data)
    for (const command of commands) {
      const refs = msg.head ? { cause: msg.head } : {}
      send_to_graph_explorer_message(command.type, command.data !== undefined ? command.data : {}, refs)
    }
  }

  function parent__forward_to_graph_explorer (msg) {
    const refs = msg.head ? { cause: msg.head } : {}
    send_to_graph_explorer_message(msg.type, msg.data, refs)
  }

  function parent__noop (msg) { fail(msg) }

  function send_to_graph_explorer_message (type, data, refs) {
    if (!can_send_to_graph_explorer()) {
      pending_to_graph_explorer.push({ type, data, refs })
      return
    }
    dispatch_to_graph_explorer_message(type, data, refs)
  }

  function flush_to_graph_explorer_queue () {
    while (can_send_to_graph_explorer() && pending_to_graph_explorer.length) {
      const next_msg = pending_to_graph_explorer.shift()
      dispatch_to_graph_explorer_message(next_msg.type, next_msg.data, next_msg.refs)
    }
  }

  function dispatch_to_graph_explorer_message (type, data, refs) {
    const head = [by, graph_explorer_sid, mid++]
    send_to_graph_explorer({ head, refs: refs || {}, type, data })
  }

  function can_send_to_graph_explorer () {
    return Boolean(send_to_graph_explorer && graph_explorer_sid && graph_explorer_channel_ready && graph_explorer_db_ready)
  }

  function get_step_commands (data) {
    if (!data) return []
    if (Array.isArray(data.commands)) return data.commands.filter(has_command_type)
    if (data.command && has_command_type(data.command)) return [data.command]
    if (has_command_type(data)) {
      return [{ type: data.type, data: data.data !== undefined ? data.data : {} }]
    }
    return []

    function has_command_type (command) {
      return command && typeof command.type === 'string' && command.type.length > 0
    }
  }

  async function onbatch (batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(load_path_raw))
      const handler = on[type] || fail
      handler(data, type)
    }

    function load_path_raw (path) { return drive.get(path).then(read_drive_file_raw) }
    function read_drive_file_raw (file) { return file.raw }
  }
  
  function fail (data, type) { console.warn('invalid message', { cause: { data, type } }) }
  function inject (data) { sheet.replaceSync(data.join('\n')) }

  function on_entries (data) {
    if (!data || !data[0]) {
      console.error('Entries data is missing or empty.')
      latest_entries = {}
      db = graphdb({})
      notify_db_initialized({})
      return
    }

    let parsed_data
    try {
      parsed_data = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    } catch (e) {
      console.error('Failed to parse entries data:', e)
      parsed_data = {}
    }

    if (typeof parsed_data !== 'object' || !parsed_data) {
      console.error('Parsed entries data is not a valid object.')
      parsed_data = {}
    }

    db = graphdb(parsed_data)
    latest_entries = parsed_data
    graph_explorer_db_ready = false
    notify_db_initialized(parsed_data)
  }

  function notify_db_initialized (entries) {
    if (!send_to_graph_explorer || !graph_explorer_sid || !graph_explorer_channel_ready) return
    dispatch_to_graph_explorer_message('db_initialized', { entries })
    graph_explorer_db_ready = true
    flush_to_graph_explorer_queue()
  }

  // ---------------------------------------------------------
  // PROTOCOL
  // ---------------------------------------------------------

  function graph_explorer_protocol (send) {
    send_to_graph_explorer = send
    Promise.resolve().then(sync_initial_state_to_child)
    return on_graph_explorer_message

    function sync_initial_state_to_child () {
      graph_explorer_channel_ready = true
      if (latest_entries !== null) {
        notify_db_initialized(latest_entries)
      }
    }

    function on_graph_explorer_message (msg) {
      const { type } = msg

      if (type.startsWith('db_')) {
        handle_db_request(msg, send)
      } else if (_.up) {
        _.up(msg)
      }
    }

    function handle_db_request (request_msg, send) {
      const { head: request_head, type: operation, data: params } = request_msg
      let result

      if (!db) {
        console.error('[graph_explorer_wrapper] Database not initialized yet')
        send_response(request_head, null)
        return
      }

      if (operation === 'db_get') {
        result = db.get(params.path)
      } else if (operation === 'db_has') {
        result = db.has(params.path)
      } else if (operation === 'db_is_empty') {
        result = db.is_empty()
      } else if (operation === 'db_root') {
        result = db.root()
      } else if (operation === 'db_keys') {
        result = db.keys()
      } else if (operation === 'db_raw') {
        result = db.raw()
      } else {
        console.warn('[graph_explorer_wrapper] Unknown db operation:', operation)
        result = null
      }

      send_response(request_head, result)

      function send_response (request_head, result) {
        // Standardized response message
        // head: [by, to, mid]
        const response_head = [by, graph_explorer_sid, mid++]
        send({
          head: response_head,
          refs: { cause: request_head }, // Reference original request
          type: 'db_response',
          data: { result }
        })
      }
    }
  }
}
function fallback_module () {
  return {
    _: {
      'graph-explorer': {
        $: ''
      },
      './graphdb': {
        $: ''
      }
    },
    api: fallback_instance
  }

  function fallback_instance () {
    return {
      _: {
        'graph-explorer': {
          $: '',
          0: '',
          mapping: {
            style: 'theme',
            runtime: 'runtime',
            mode: 'mode',
            flags: 'flags',
            keybinds: 'keybinds',
            undo: 'undo',
            docs: 'docs'
          }
        },
        './graphdb': {
          $: ''
        }
      },
      drive: {
        'theme/': {
          'style.css': {
            raw: `
              :host {
              display: block;
              height: 100%;
              width: 100%;
              }
            `
          }
        },
        'entries/': {
          'entries.json': {
            $ref: 'entries.json'
          }
        },
        'runtime/': {
          'node_height.json': { raw: '16' },
          'vertical_scroll_value.json': { raw: '0' },
          'horizontal_scroll_value.json': { raw: '0' },
          'selected_instance_paths.json': { raw: '[]' },
          'confirmed_selected.json': { raw: '[]' },
          'instance_states.json': { raw: '{}' },
          'search_entry_states.json': { raw: '{}' },
          'last_clicked_node.json': { raw: 'null' },
          'view_order_tracking.json': { raw: '{}' }
        },
        'mode/': {
          'current_mode.json': { raw: '"menubar"' },
          'previous_mode.json': { raw: '"menubar"' },
          'search_query.json': { raw: '""' },
          'multi_select_enabled.json': { raw: 'false' },
          'select_between_enabled.json': { raw: 'false' }
        },
        'flags/': {
          'hubs.json': { raw: '"default"' },
          'selection.json': { raw: 'true' },
          'recursive_collapse.json': { raw: 'true' }
        },
        'keybinds/': {
          'navigation.json': {
            raw: JSON.stringify({
              ArrowUp: 'navigate_up_current_node',
              ArrowDown: 'navigate_down_current_node',
              'Control+ArrowDown': 'toggle_subs_for_current_node',
              'Control+ArrowUp': 'toggle_hubs_for_current_node',
              'Alt+s': 'multiselect_current_node',
              'Alt+b': 'select_between_current_node',
              'Control+m': 'toggle_search_mode',
              'Alt+j': 'jump_to_next_duplicate'
            })
          }
        },
        'undo/': {
          'stack.json': { raw: '[]' }
        },
        'docs/': {
          'README.md': {
            $ref: 'README.md'
          }
        }
      }
    }
  }
}
